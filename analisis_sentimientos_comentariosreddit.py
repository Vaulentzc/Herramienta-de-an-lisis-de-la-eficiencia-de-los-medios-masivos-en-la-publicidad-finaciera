# -*- coding: utf-8 -*-
"""Analisis-sentimientos-ComentariosReddit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FSZQGcnkhANedeMRcov6VV9nfaaZ7OUm
"""

#Esto es un programa de analisis de sentimientos en Reddit
!pip install textblob spacy vaderSentiment nltk wordcloud matplotlib
!python -m textblob.download_corpora
!python -m spacy download es_core_news_sm

#Importar librerias
import re
import unicodedata
import spacy
import praw
import pandas as pd
import matplotlib.pyplot as plt
from textblob import TextBlob
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from wordcloud import WordCloud
import time

# Autenticación en Reddit con PRAW
reddit = praw.Reddit(
    client_id="NEGS3QsSHL9JRx6bJE8vvw",
    client_secret="GvdXhnOY6VbbBdJLKy612MYlOkzoWA",
    user_agent="Sentiment Analyzer by /u/vaulent"
)

# Lista de subreddits donde buscar
subreddits = ["personalfinance"]

# Lista de términos de búsqueda relacionados con créditos hipotecarios
search_queries = ["mortgage"]

#Evitar duplicados con un conjunto (set)
comments_set = set()

for subreddit_name in subreddits:
    try:
        subreddit = reddit.subreddit(subreddit_name)
        print(f"Buscando en r/{subreddit_name}...")

        for query in search_queries:
            try:
                print(f"Buscando: '{query}'...")
                for submission in subreddit.search(query, limit=300):  # Puedes cambiar el límite
                    submission.comments.replace_more(limit=0)  # Evitar "MoreComments"

                    for comment in submission.comments.list():
                        comments_set.add(comment.body)  # Agregar comentario al set

                time.sleep(1)  # Evita sobrecargar la API de Reddit

            except Exception as e:
                print(f"Error en búsqueda '{query}': {e}")

    except Exception as e:
        print(f"No se pudo acceder a r/{subreddit_name}: {e}")

# Convertir comentarios a DataFrame
df = pd.DataFrame(list(comments_set), columns=['texto'])

if df.empty:
    print("⚠ No se encontraron comentarios. Revisa los subreddits y términos de búsqueda.")
else:
    print(f"✅ Se obtuvieron {len(df)} comentarios únicos.")

# Función para limpiar texto
def clean_text(text):
    text = str(text)
    text = re.sub(r'@[A-Za-z0-9]+', '', text)  # Eliminar menciones
    text = re.sub(r'#', '', text)  # Eliminar hashtags
    text = re.sub(r'RT[\s]+', '', text)  # Eliminar RT
    text = re.sub(r'https?://\S+|www\.\S+', '', text)  # Eliminar URLs
    text = re.sub(r'[^\w\s]', '', text)  # Eliminar signos de puntuación
    text = text.lower()  # Convertir a minúsculas
    text = unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode('utf-8')  # Quitar acentos
    return text

# Aplicar limpieza
df['Cleaned_Text'] = df['texto'].apply(clean_text)

# Inicializar analizador de sentimientos
analyzer = SentimentIntensityAnalyzer()

# Funciones para análisis de sentimientos
def get_polarity(text):
    return TextBlob(text).sentiment.polarity

def get_subjectivity(text):
    return TextBlob(text).sentiment.subjectivity

def get_sentiment(text):
    score = analyzer.polarity_scores(text)['compound']
    if score < 0:
        return 'Negativo'
    elif score == 0:
        return 'Neutral'
    else:
        return 'Positivo'

# Aplicar análisis
df['Polarity'] = df['Cleaned_Text'].apply(get_polarity)
df['Subjectivity'] = df['Cleaned_Text'].apply(get_subjectivity)
df['Sentiment'] = df['Cleaned_Text'].apply(get_sentiment)

# Mostrar los primeros resultados
print(df.head())

# Generar una nube de palabras
all_words = ' '.join([text for text in df['Cleaned_Text']])
wordcloud = WordCloud(width=800, height=500, max_font_size=110, background_color='white').generate(all_words)
plt.figure(figsize=(10, 6))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

# Graficar distribución de análisis de sentimientos
plt.figure(figsize=(6, 4))
df['Sentiment'].value_counts().plot(kind='bar', color=['red', 'blue', 'green'])
plt.title('Distribución de Sentimientos')
plt.xlabel('Sentimiento')
plt.ylabel('Frecuencia')
plt.show()